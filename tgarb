--[[ 
  Move-to-Nearest-Base v1
  LocalScript - place in StarterPlayerScripts
  Features:
   - زر يسار الشاشة قابل للسحب
   - عند الضغط: البحث عن أقرب Part اسمه "base" (غير حساس لحالة الحروف)
   - توليد مسار Pathfinding مع تجنّب العوائق + إعادة حساب عند الانسداد
   - رسم المسار بخطوط نيون على الخريطة
   - الضغط مرة ثانية يوقف الحركة ويمسح المسار
--]]

local Players = game:GetService("Players")
local PathfindingService = game:GetService("PathfindingService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local StarterGui = game:GetService("StarterGui")

local player = Players.LocalPlayer
local function getChar()
	return player.Character or player.CharacterAdded:Wait()
end

-- ===== GUI =====
local screen = Instance.new("ScreenGui")
screen.Name = "AutoPathUI_v1"
screen.ResetOnSpawn = false
screen.IgnoreGuiInset = true
screen.Parent = player:WaitForChild("PlayerGui")

-- label نسخة/إصدار (فوق يمين)
do
	local vlabel = Instance.new("TextLabel")
	vlabel.Name = "Version"
	vlabel.Size = UDim2.new(0, 60, 0, 24)
	vlabel.Position = UDim2.new(1, -70, 0, 8)
	vlabel.AnchorPoint = Vector2.new(0,0)
	vlabel.BackgroundTransparency = 0.25
	vlabel.BackgroundColor3 = Color3.fromRGB(20,20,20)
	vlabel.Text = "v1"
	vlabel.TextColor3 = Color3.fromRGB(255,255,255)
	vlabel.TextScaled = true
	vlabel.Font = Enum.Font.GothamBold
	vlabel.Parent = screen
end

-- زر يسار الشاشة (قابل للسحب/التحريك)
local button = Instance.new("TextButton")
button.Name = "GoToBaseButton"
button.Size = UDim2.new(0, 180, 0, 48)
button.Position = UDim2.new(0, 12, 0.5, -24)
button.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
button.AutoButtonColor = true
button.Text = "اذهب لأقرب base"
button.TextScaled = true
button.TextColor3 = Color3.fromRGB(255,255,255)
button.Font = Enum.Font.GothamBold
button.BorderSizePixel = 0
button.Parent = screen
-- زوايا ناعمة
local uic = Instance.new("UICorner"); uic.CornerRadius = UDim.new(0,16); uic.Parent = button
-- ظل بسيط
local uiStroke = Instance.new("UIStroke"); uiStroke.Thickness = 2; uiStroke.Color = Color3.fromRGB(90,90,90); uiStroke.Parent = button

-- سحب يدوي (Draggable مخصص لضمان عمله بكل الأماكن)
do
	local dragging = false
	local dragStart, startPos
	local inputConn, moveConn, endConn

	local function update(input)
		local delta = input.Position - dragStart
		button.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
	end

	button.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = button.Position
			inputConn = input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
					if inputConn then inputConn:Disconnect() end
					if moveConn then moveConn:Disconnect() end
				end
			end)
			moveConn = game:GetService("UserInputService").InputChanged:Connect(function(inp)
				if dragging and (inp.UserInputType == Enum.UserInputType.MouseMovement or inp.UserInputType == Enum.UserInputType.Touch) then
					update(inp)
				end
			end)
		end
	end)
end

-- ===== رسم المسار =====
local pathFolder = workspace:FindFirstChild("PathVis") or Instance.new("Folder", workspace)
pathFolder.Name = "PathVis"

local function clearPath()
	for _, obj in ipairs(pathFolder:GetChildren()) do
		obj:Destroy()
	end
end

local function drawSegment(p0, p1)
	local dir = (p1 - p0)
	local dist = dir.Magnitude
	if dist < 0.05 then return end

	local part = Instance.new("Part")
	part.Name = "PathSeg"
	part.Anchored = true
	part.CanCollide = false
	part.Material = Enum.Material.Neon
	part.Color = Color3.fromRGB(0, 170, 255)
	part.Size = Vector3.new(0.25, 0.25, dist)
	part.CFrame = CFrame.lookAt((p0 + p1)/2, p1) * CFrame.new(0,0,-dist/2)
	part.Parent = pathFolder
end

local function drawWaypoint(pos)
	local sphere = Instance.new("Part")
	sphere.Name = "PathPoint"
	sphere.Shape = Enum.PartType.Ball
	sphere.Anchored = true
	sphere.CanCollide = false
	sphere.Material = Enum.Material.Neon
	sphere.Color = Color3.fromRGB(0, 255, 170)
	sphere.Size = Vector3.new(0.5,0.5,0.5)
	sphere.CFrame = CFrame.new(pos + Vector3.new(0,0.2,0))
	sphere.Parent = pathFolder
end

local function drawPath(waypoints)
	clearPath()
	for i, wp in ipairs(waypoints) do
		drawWaypoint(wp.Position)
		if i > 1 then
			drawSegment(waypoints[i-1].Position, wp.Position)
		end
	end
end

-- ===== منطق المسار =====
local function findNearestBase(fromPos: Vector3)
	local nearest, bestDist = nil, math.huge
	for _, d in ipairs(workspace:GetDescendants()) do
		if d:IsA("BasePart") and d.Name:lower() == "base" then
			local dist = (d.Position - fromPos).Magnitude
			if dist < bestDist then
				bestDist = dist
				nearest = d
			end
		end
	end
	return nearest, bestDist
end

local function computePath(startPos: Vector3, goalPos: Vector3)
	local path = PathfindingService:CreatePath({
		AgentRadius = 2.5,
		AgentHeight = 5.0,
		AgentCanJump = true,
		WaypointSpacing = 3.0,
		Costs = {
			-- يمكنك تعديل تكاليف المناطق لو تستخدم مناطق ملاحية
		}
	})
	local success, err = pcall(function()
		path:ComputeAsync(startPos, goalPos)
	end)
	if not success then
		warn("Path Compute error:", err)
		return nil
	end
	if path.Status ~= Enum.PathStatus.Success then
		return nil
	end
	return path
end

local moving = false
local stopFlag = false

local function stopMoving(reason)
	stopFlag = true
	moving = false
	clearPath()
	button.Text = "اذهب لأقرب base"
	if reason then warn("Stopped:", reason) end
end

local function moveToNearestBase()
	if moving then
		-- toggle لإيقاف الحركة
		return stopMoving("ToggledOff")
	end

	local char = getChar()
	local hrp: BasePart = char:WaitForChild("HumanoidRootPart")
	local hum: Humanoid = char:WaitForChild("Humanoid")

	local targetBase = nil
	targetBase = select(1, findNearestBase(hrp.Position))
	if not targetBase or not targetBase:IsDescendantOf(workspace) then
		StarterGui:SetCore("SendNotification", {
			Title = "ما فيه هدف",
			Text = "ما وجدت أي Part اسمه base في الخريطة.",
			Duration = 3
		})
		return
	end

	moving = true
	stopFlag = false
	button.Text = "إيقاف (جاري المسير...)"

	local lastRepathTime = 0
	local REPATH_COOLDOWN = 0.8
	local TARGET_REACH_DIST = 4.0

	-- متابعة حتى الوصول
	while moving and targetBase and targetBase.Parent do
		if stopFlag then break end

		-- لو الهدف تحرك/انحذف، نعيد تعيينه لأقرب واحد حالياً
		local nearestNow = select(1, findNearestBase(hrp.Position))
		if nearestNow and nearestNow ~= targetBase then
			targetBase = nearestNow
		end

		local path = computePath(hrp.Position, targetBase.Position + Vector3.new(0, 2, 0))
		if not path then
			-- ما فيه مسار؟ جرّب إعادة الحساب بعد لحظة
			RunService.Heartbeat:Wait()
			if (time() - lastRepathTime) > REPATH_COOLDOWN then
				lastRepathTime = time()
			end
		else
			local waypoints = path:GetWaypoints()
			drawPath(waypoints)

			for i, wp in ipairs(waypoints) do
				if stopFlag then break end

				-- قفز إذا مطلوب
				if wp.Action == Enum.PathWaypointAction.Jump then
					hum.Jump = true
				end

				hum:MoveTo(wp.Position)
				local reached = false
				local conn
				conn = hum.MoveToFinished:Connect(function(ok)
					reached = true
					if conn then conn:Disconnect() end
				end)

				-- مراقبة الانسداد/الانحراف، لو انسد نعيد حساب
				local startTick = tick()
				while not reached do
					if stopFlag then break end

					-- لو المسافة للهدف النهائي صارت قريبة كفاية نوقف
					if (targetBase.Position - hrp.Position).Magnitude <= TARGET_REACH_DIST then
						reached = true
						break
					end

					-- لو في مسار صار غير صالح (مثلاً جدار جديد)، أعد الحساب
					-- نعمل تبريد بسيط عشان ما نعيد الحساب كثير
					if (tick() - startTick) > 1.5 and (time() - lastRepathTime) > REPATH_COOLDOWN then
						lastRepathTime = time()
						break
					end
					RunService.Heartbeat:Wait()
				end

				-- قريب من الهدف؟ خلص
				if (targetBase.Position - hrp.Position).Magnitude <= TARGET_REACH_DIST then
					stopMoving("Arrived")
					StarterGui:SetCore("SendNotification", {
						Title = "وصلت",
						Text = "تم الوصول لأقرب base.",
						Duration = 2
					})
					return
				end

				-- لو كسرنا الحلقة الداخلية قبل الوصول، معناته بنعيد الحساب
				if not moving or stopFlag then break end
			end
		end
	end

	stopMoving()
end

-- ربط زر التشغيل/الإيقاف
button.MouseButton1Click:Connect(moveToNearestBase)

-- ضمان التنظيف عند الموت/الريسباون
player.CharacterAdded:Connect(function()
	stopMoving("Respawn")
end)
